# Artalytics R Style and Coding Guide (for AI Platforms)

This guide summarizes personal coding conventions, architectural principles, and communication preferences for developing R code in the Artalytics platform. It is written for AI assistants (like ChatGPT or Claude) to consistently generate code and documentation that align with these standards. All code is written in R, organized as packages, and follows a unified style across the ecosystem.

## Communication and General Style

* **Clarity and Professional Tone:** All written communication (code comments, documentation, commit messages) should be clear, concise, and professional. Avoid slang, jokes, or personal remarks. Use an informative, neutral tone. In documentation and comments, prefer the active voice and present tense when describing functionality or behavior.

* **Comments and Documentation:** Comment non-obvious logic or important nuances, but avoid cluttering the code with superfluous comments. Assume the reader is a developer or AI agent familiar with R. Focus comments on *why* or *how* when the purpose isn’t immediately clear from the code. Documentation (Roxygen) should be factual and straight to the point, describing what functions do, their parameters, return values, and examples of use.

* **Commit Messages (if applicable):** Use imperative mood and be concise (e.g., “Add function to calculate X” or “Fix Y bug in Z module”). Reference issue or task IDs when relevant. Explain *what* changed and *why* if it’s not obvious, but avoid unnecessary detail. Keep line length reasonable (\<= 72 chars for the first line).

## Project Structure and Architecture

* **Package-Based Organization:** The entire platform is composed of **R packages** – each repository is a standalone R package with a conventional structure (R/, man/, tests/, etc.)[\[1\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=All%20Artalytics%20R%20packages%20use,some%20additions%20for%20Shiny%20modules). Every Shiny component or backend utility is implemented as a package, facilitating modular development and reuse. For example, core utilities reside in the **artcore** package, shared helpers in **artutils**, and each Shiny UI module (e.g. modBrowse, modUpload, modGallery) is its own R package[\[2\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=UI%20Module%20Packages%20%28Shiny,for%20the%20platform%E2%80%99s%20web). This ensures a predictable layout and easy navigation for both developers and AI agents[\[3\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Directory%20Structure).

* **Layered Dependencies:** Packages follow a layered architecture with clear dependency directions. **artcore** is the foundational base (database connections, paths, etc.), and **artutils** builds on artcore (and base R libraries) for higher-level utilities[\[4\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=The%20Artalytics%20platform%20is%20composed,with%20a%20layered%20dependency%20structure). Domain-specific packages like **artopenai** (AI integration) or **artopensea** (API integration) depend on artcore and sometimes artutils – but critically, lower-level packages do **not** depend on higher-level ones (e.g. artutils should not depend on artopenai)[\[5\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=Functional%20packages%20like%20artopenai%20,should%20not%20depend%20on). Processing orchestrators like **artpipelines** can depend on multiple lower layers to coordinate their functionality[\[6\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=uploads). Shiny UI module packages (modUpload, modGallery, etc.) sit at the top, relying on artutils and invoking artpipelines as needed[\[7\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=Shiny%20modules%20like%20modUpload%20%2C,These%20modules%20use%20artutils). There are no circular or upward dependencies; each layer only calls into the layers beneath it, never the reverse.

* **No Local Assets – Use CDN:** In accordance with v2 platform guidelines, **no static files are served from local package directories**. All images, CSS, JS, and other assets are stored in cloud buckets and accessed via helper functions that generate CDN URLs[\[8\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=Problem%3A%20The%20above%20approach%20conflicts,goal%20is%20to%20treat%20the). Do not reference files under inst/www or use hardcoded URLs directly in code. Instead, use utility functions like artutils::pathImageAsset("filename.png") or artcore::cdn\_asset\_url(bucket, path) to retrieve the correct CDN URL for an asset[\[9\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=explicitly%20state%20that%20no%20package,deployability%20and%20ensuring%20consistency%20across)[\[10\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=tags%24link%28rel%3D). This ensures a single source of truth for assets and makes deployments consistent. For example, a logo image that used to be inst/app/www/images/logo.png would be referenced as shiny::img(src \= artutils::pathImageAsset("logo.png")) rather than a local file path[\[11\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=Use%20CDN%20for%20Logo%20and,For%20example). All packages must adhere to the “no local assets” rule: static resources are hosted externally and fetched at runtime via the provided CDN helpers.

* **Environment Configuration:** No sensitive configuration or credentials are kept in code or files. Use environment variables for all secrets, keys, or deployment-specific settings. *Never* commit API keys, passwords, or secret tokens to the repo[\[12\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=No%20Credentials%20in%20Repos%3A%20Never,Renviron%20%20that). Instead, reference them via Sys.getenv() or similar, and document required env vars in README or config documentation. Code that depends on certain environment flags (e.g., production vs. demo mode) should read the appropriate env var (ART\_USE\_PG\_CONF, ART\_RUN\_AS\_DEMO, etc.) and alter behavior accordingly[\[13\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=Deprecated%20Env%20Variables%3A%20While%20the,They%20should%20be%20renamed%20for). This makes the code portable and secure. Ensure that any logic which might fail due to missing configuration is gated or checked – e.g., if a database connection env var is unset, handle it gracefully rather than crashing.

## Coding Conventions

We maintain a consistent coding style across all R packages for readability and predictability[\[14\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=We%20maintain%20%20a%20,Key%20style%20guidelines%20include). Key conventions include:

* **Tabular Data:** Use **data.table** for data manipulation and storage of tabular data, instead of dplyr or other tidyverse libraries[\[15\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Favor%20data,This%20also%20reduces). Data processing should favor data.table syntax (e.g., DT\[i, j, by\]) and chaining with \[\] for clarity and performance. The tidyverse is not attached in these projects; base R and data.table are preferred to minimize dependencies and maximize speed[\[16\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=than%20dplyr%20%20or%20other,This%20also%20reduces%20external%20dependencies).

* **String Handling:** Use **stringr** (stringi) for string operations instead of base R functions[\[17\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=String%20Handling%3A%20We%20prefer%20stringr,are%20complex%2C%20commented%20for%20clarity). Functions like stringr::str\_detect, str\_replace, etc., should replace base equivalents (grepl, sub, etc.) for consistency and better regex handling. Constructing strings should be done carefully: use paste0() for simple concatenation (no separator)[\[18\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Concatenation%3A%20Use%20paste0,makes%20the%20behavior). Avoid building file paths or URLs by manual paste if possible – use helper functions or file.path for file system paths. If a complex string interpolation greatly improves readability (e.g., inserting multiple variables into a long string), using stringr::str\_glue is acceptable for clarity, but default to straightforward paste0 in most cases.

* **Pipe Operator:** Use R’s native pipe |\> (introduced in R 4.1+) for piping operations[\[19\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=external%20dependencies,style%20when%20it%20improves%20readability). Do **not** use the magrittr %\>% pipe, as it adds an external dependency. The native pipe is enabled in project settings and should be used whenever it improves code clarity for sequential transformations. Use pipes judiciously: they can make code more readable when chaining operations, but don’t sacrifice clarity – it’s okay to break a chain into intermediate steps if it aids understanding[\[20\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Code%20Conciseness%3A%20Aim%20to%20write,Comments%20should%20be%20added%20for).

* **External Packages and Namespaces:** Always call external package functions with an explicit namespace (e.g., package::function). Packages should be referenced in code rather than using library() calls inside functions or assuming a search path. This makes dependencies clear and avoids conflicts. In tests or examples, even if you attach a package, prefer using explicit pkg::fun for clarity. For example, image processing in the code uses calls like magick::image\_read(...) |\> magick::image\_resize(...) |\> magick::image\_raster() and converts to a data.table via data.table::as.data.table()[\[21\]](https://github.com/artalytics/artutils/blob/e3fcb8f371ecaf9d75e9ee7f7827c1c299181a4f/R/getImageRaster.R#L7-L14) – each external function is prefixed with its package. This convention ensures anyone reading the code (or AI analyzing it) knows exactly which package a function comes from. The only exceptions are base R functions and in-package calls.

* **Minimal Dependencies:** Strive to keep the dependency footprint lean. Avoid bringing in heavy packages for minor conveniences. Use base R or internal utilities if a task can be accomplished without an extra dependency. Every new import should be justified. By favoring data.table and base R over large frameworks, the code stays efficient and reduces potential conflicts[\[16\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=than%20dplyr%20%20or%20other,This%20also%20reduces%20external%20dependencies). Similarly, prefer writing a small helper function internally rather than pulling in a single-use package.

* **Concise yet Readable Code:** Aim for code that is efficient in both performance and lines of code, but never at the expense of clarity[\[20\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Code%20Conciseness%3A%20Aim%20to%20write,Comments%20should%20be%20added%20for). Vectorized operations and data.table chaining are preferred over long loops when they simplify the code. However, if a single-line chain or nested function call becomes hard to understand, break it into multiple steps with meaningful intermediate variables. We value **clean, easy-to-follow logic** over clever one-liners. Use blank lines to separate logical sections of code, and indent according to standard R (usually 2 spaces). Ensure all code is formatted to pass linters (no trailing whitespace, proper indentation, etc.).

* **Naming Conventions:** Use snake\_case for object names (functions, variables)[\[22\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Naming%20Conventions%3A%20Use%20snake_case%20,to%20ease%20navigation). Functions should be verbs or verb phrases (e.g., calculate\_stats), and boolean variables should sound like booleans (e.g., is\_valid). S3 methods follow the generic.class naming as usual. Constants and configuration options can be in ALL\_CAPS (e.g., default values or env var names). Filenames in the R/ directory are typically also snake\_case and reflect their contents (matching a key function or topic in that file). Avoid ambiguous abbreviations; names should be descriptive but not overly long.

* **Use of TODOs:** It is acceptable to include \# TODO: comments in the code to mark areas that need follow-up or improvement. These act as internal reminders for future development. Keep TODO comments brief and focused on the needed change. For instance, a comment like \#\# TODO – consolidate into a single waiter might be placed to note a temporary solution in Shiny code that should be refactored later[\[23\]](https://github.com/artalytics/modUpload/blob/f7cefc760bb20b73dc8259a1723b81262980c3ad/R/app-server.R#L31-L38). Do not leave critical functionality as a TODO without an issue tracker reference, but using TODO tags for minor improvements or non-blocking enhancements is fine.

## Logging and Debugging

* **Structured Logging:** Do not use print() or cat for logging or debug output in any production code. Instead, use the **rdstools logging** utilities (e.g., rdstools::log\_info(), log\_warn(), log\_error()) for consistent, structured logs. These functions integrate with the platform’s logging framework and can be configured or aggregated centrally. Any diagnostic messages, info statements, or warnings in server logic should go through log\_\* calls[\[24\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=solution%20%28e,isn%E2%80%99t%20wrapped%20in%20a). This ensures that logs include timestamps, levels, and are easily toggleable. Remove or convert any leftover print() statements that were used during debugging to proper logging calls or eliminate them if not needed. In tests or temporary development code, you may use message() or print() for quick output, but these should not remain in committed code.

* **Avoid Interactive Debug Code:** Do not leave browser() calls, setBreakpoint, or interactive readline() prompts in the code. Use logs and tests to debug instead. Likewise, avoid writing temp files or outputs to the console for debugging purposes in committed code. If something must be left in for development convenience, guard it behind an explicit debug flag or environment variable (so it doesn’t execute in production or CI).

## Error Handling and Security

* **Graceful Error Handling:** Wrap error-prone operations in tryCatch() or otherwise handle potential failures, especially for I/O, network calls, or database operations. The code should **fail gracefully** and not crash the Shiny app or pipeline. For example, if an external API call (like OpenAI) fails or times out, catch the error and log it, returning an informative result or fallback. In Shiny modules, use validate(need(...)) or other Shiny-friendly error handling to inform the user rather than breaking the app. The modernization review explicitly noted places where lack of tryCatch caused crashes – e.g., a DB call that stops the app if the connection isn’t configured[\[25\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=Lack%20of%20Error%20Handling%3A%20The,ART_USE_PG_CONF%20%20is%20unset). Avoid bare stop() calls on expected errors in server code; instead, return an error message or signal it in a controlled way so the UI can handle it.

* **Environment-Based Gating:** Use environment variables to control behavior that should differ between development, testing, and production. For instance, if certain heavy computations or external calls should be skipped in a demo mode, check an env var like ART\_RUN\_AS\_DEMO and adjust logic accordingly rather than hardcoding test vs. prod differences. Similarly, if a feature is experimental or not ready, guard it behind an if (Sys.getenv("FEATURE\_X") \== "true") to keep it disabled until ready, rather than commenting out blocks of code. This allows toggling features without code changes and integrates with CI (where you can set env vars for testing scenarios).

* **Security – No Secrets in Code:** As noted, never include plaintext credentials, API tokens, or personal data in the codebase[\[12\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=No%20Credentials%20in%20Repos%3A%20Never,Renviron%20%20that). Use Sys.getenv("KEY\_NAME") to retrieve secrets. If a package needs to rely on a secret (like an API key), document the requirement and perhaps provide an initializer function to check it, but leave actual values to be provided by the deployment environment or developer’s .Renviron. All OAuth or API secrets, database passwords, etc., are configured externally. This practice is crucial because once something is committed to Git, it can’t be fully removed. By keeping secrets out of code, the repository remains safe to share and open-source portions (if needed) without risk.

## Shiny Modules and Application Structure

* **Shiny as Modular Packages:** All Shiny applications or components are built using **shiny modules** encapsulated in packages. Rather than one monolithic Shiny app file, UI functionality is divided into module packages (e.g., modUpload, modBrowse, etc.), each providing a UI and server function pair (modXYZUI, modXYZServer). These modules can be independently developed, tested, and then plugged into the main app container. The main application (Artalytics.App) is itself an R package (often called **appPlatform** or similar) that depends on all the module packages and assembles them into a cohesive UI[\[2\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=UI%20Module%20Packages%20%28Shiny,for%20the%20platform%E2%80%99s%20web)[\[26\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=interface,share%20the%20platform%E2%80%99s%20coding%20conventions). This architecture means each module package has its own namespace, tests, and documentation, and shares the same coding standards as the rest of the ecosystem.

* **Example – Main App Package:** The main app (platform) package contains the high-level Shiny application (e.g., in app\_server.R and app\_ui.R) and imports the modules. It is designed such that deployment is simply installing all required packages and running the app’s entrypoint. This package also includes any global configuration and the Docker setup for deployment. By having the app as a package, we can easily version it and manage its dependencies on the module packages via DESCRIPTION. The main app is typically deployed as a **Docker container** running a Shiny server or RStudio Connect, ensuring a consistent environment[\[27\]](file://file-MzkyFMuCXvZa4EmWMTmKxM#:~:text=packages%20and%20the%20app%20launched,latest%20versions%20of%20these%20packages). Each release of the app corresponds to a set of package versions (ensuring compatibility across modules).

* **Testing Shiny Modules:** UI modules are tested similarly to other code. Wherever possible, server logic of modules is structured to be testable without a live Shiny session (e.g., by using functions that take parameters and return values which can be checked in unit tests). For interactive components and reactive outputs, we utilize **shinytest2** for end-to-end testing of Shiny modules in a headless browser environment[\[28\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=considerations%3A%20We%20may%20use%20snapshot,inputs). Shinytest2 allows simulating user input and validating expected UI changes or outputs. We also use testthat::expect\_snapshot() for static outputs and warnings to catch unintended changes[\[29\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Snapshot%20and%20UI%20Testing%3A%20For,inputs). All modules have corresponding tests in their tests/testthat directories, ensuring that adding or modifying features doesn’t break existing functionality.

## Documentation and Testing

* **Roxygen2 Documentation:** All exported functions **must** have Roxygen2 documentation comments above their definitions[\[30\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=documentation%20are%20kept%20in%20sync,the%20order%20in). These comments should include a one-line summary, a more detailed description if necessary, @param entries for each parameter (with clear, concise explanations), @return describing the return value, and examples (@examples) demonstrating typical usage. If relevant, also include @seealso or references to related functions. Internal (unexported) functions that are complex or important should also have at least a brief comment or Roxygen block (you can use @noRd to avoid generating an .Rd file for internal documentation). Consistent and complete documentation is important both for human developers and for AI assistants that might read the docs to understand usage[\[31\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Function%20Documentation%20and%20Export%3A%20All,ones%20often%20get%20a%20%40noRd). After writing or updating docs, remember to rebuild the package or run devtools::document() so that man pages are up to date.

* **Vignettes and Examples:** Where appropriate, longer examples or usage tutorials are included as vignettes (using R Markdown or Quarto in the vignettes/ directory). Shiny modules may have example apps under inst/ for manual testing. Ensure any such examples are functional and up to date. Examples in documentation should be realistic but not overly complex, and should run quickly. Use \\dontrun{} or conditional logic in examples if they require external resources (like an API) to avoid failures in CRAN checks or CI.

* **Unit Testing:** We use **testthat** (edition 3\) for all unit tests[\[32\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=testthat%20Framework%3A%20We%20use%20testthat,or%20R%20CMD%20check). Every package has a tests/testthat/ directory with test files. Follow the standard context \-\> test\_that structure (though context() calls are no longer needed in edition 3). Tests should cover all critical logic paths, edge cases, and error conditions[\[33\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Coverage%20of%20Core%20Logic%3A%20Tests,return%20a). Aim for high coverage on core functionality. For example, if a function produces a data.table result, have a test that checks the structure and contents of that result (using data.table operations or testthat expectations). Use testthat::skip() where necessary (for example, skip tests that require an internet connection or API key if not available). In CI, all tests are run on multiple platforms, so ensure tests don’t rely on OS-specific behavior.

* **Shiny Testing:** As mentioned, use **shinytest2** for interactive testing and expect\_snapshot() for output comparison. Testing Shiny UI can include verifying that given some sample inputs, the server returns the expected values or that certain reactive values change. Write tests to simulate the module’s server logic with sample reactive inputs (you can use shiny::testServer() in testthat to run module server functions with fake inputs).

* **Continuous Integration (CI):** All packages are set up with GitHub Actions CI workflows that run R CMD check, linters, and tests on each push. **Code must pass R CMD check without errors or warnings**, and must pass the linter checks to be considered merge-ready[\[34\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=R%20CMD%20Check%3A%20Every%20package,expected%20to%20run%20R%20CMD)[\[35\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Linting%3A%20We%20use%20lintr%20in,Note). We use **lintr** with the default tidyverse style guidelines (2-space indent, snake\_case names, etc.) enforced[\[35\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Linting%3A%20We%20use%20lintr%20in,Note). Before committing, you should run lintr::lint\_package() and ensure there are no lint warnings. Our CI will run these as well (though lint issues may not fail the build, we treat them seriously). A pull request will not be approved until R CMD check (including tests) passes cleanly on CI. This process keeps the main branch stable and ensures consistency across the codebase.

* **Linters and Style Checks:** We have no custom lint rules beyond the defaults, so sticking to base R/Tidyverse style (which aligns with our conventions) is sufficient[\[35\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Linting%3A%20We%20use%20lintr%20in,Note). This includes: limit line lengths (around 80 characters when possible), indent nested code properly, use spaces around infix operators (e.g., assignments like x \<- 1 have spaces), and no trailing whitespace. Naming was covered above (snake\_case etc.). The code style should be uniform so that diffs focus on meaningful changes, and AI-generated code should blend in with human-written code.

* **Documentation of Deviations:** In the rare case that a specific repository needs to deviate from these conventions, it should be documented (e.g., in that repo’s README or an AGENTS.md note specific to it)[\[36\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Documentation%20of%20Deviations%3A%20This%20AGENTS,For). But as a rule, assume these guidelines apply everywhere unless explicitly noted otherwise.

## **Quick Reference Checklist**

* **Project Structure:** Organize code as standard R packages (with R/, man/, tests/, etc.), one package per module or component. No ad-hoc scripts or loose .R files – everything goes into a package structure[\[1\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=All%20Artalytics%20R%20packages%20use,some%20additions%20for%20Shiny%20modules).

* **Layered Architecture:** Respect dependency layering – core utilities at the base (artcore), shared helpers (artutils) on core, specialized packages on core/util, pipelines orchestrate, and Shiny modules depend on those. No reverse dependencies or circular links[\[5\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=Functional%20packages%20like%20artopenai%20,should%20not%20depend%20on).

* **No Local Assets:** Do not include or serve static files from within packages. Use CDN-based storage for assets and access them via provided helper functions (e.g., cdn\_asset\_url, pathImageAsset)[\[8\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=Problem%3A%20The%20above%20approach%20conflicts,goal%20is%20to%20treat%20the).

* **Data Handling:** Use data.table for data frames and tabular operations. Avoid attaching tidyverse packages; rely on base R and data.table for speed and minimal dependencies[\[37\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Favor%20data,This%20also%20reduces%20external%20dependencies).

* **Strings:** Use stringr functions for string manipulation (e.g., str\_detect, str\_replace). Use paste0() for concatenation without separators[\[18\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Concatenation%3A%20Use%20paste0,makes%20the%20behavior). If constructing complex strings with variables, str\_glue can be used for readability (but prefer simple paste0 when possible).

* **Pipes:** Use the native R pipe (|\>) for chaining operations where it improves clarity[\[38\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=external%20dependencies,especially%20for%20sequential). Do not use %\>% (magrittr) – avoid that dependency.

* **External Calls:** Always call external package functions with package::function syntax. No implicit dependencies. Make it obvious where each function comes from (e.g., DBI::dbGetQuery, ggplot2::ggplot).

* **Efficiency & Clarity:** Write concise code using vectorized operations and data.table chaining rather than verbose loops. But don’t sacrifice readability – break up overly complex one-liners and use intermediate variables if needed[\[20\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Code%20Conciseness%3A%20Aim%20to%20write,Comments%20should%20be%20added%20for).

* **Naming:** Use snake\_case for function and variable names[\[22\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Naming%20Conventions%3A%20Use%20snake_case%20,to%20ease%20navigation). Use descriptive names that convey purpose. Constants in ALL\_CAPS. Follow established naming patterns for reactive values, UI ids, etc., for consistency.

* **Logging:** No print() in production code. Use rdstools::log\_info/warn/error for logging messages[\[24\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=solution%20%28e,isn%E2%80%99t%20wrapped%20in%20a). Remove or guard any debug prints.

* **Error Handling:** Wrap risky operations in tryCatch or check conditions to prevent crashes[\[25\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=Lack%20of%20Error%20Handling%3A%20The,ART_USE_PG_CONF%20%20is%20unset). Handle errors gracefully and provide informative messages rather than letting the program terminate unexpectedly.

* **Env Variables:** Use environment variables for configuration, secrets, and mode toggles. Never hardcode secrets or config paths in code[\[12\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=No%20Credentials%20in%20Repos%3A%20Never,Renviron%20%20that). Document required env vars and default to safe behavior if they’re missing.

* **TODOs:** You may include \# TODO: comments to mark areas for future improvement or refactoring. Keep these TODO notes actionable and remove them once addressed.

* **Documentation:** Every exported function has a Roxygen2 doc string with description, @param, @return, and examples[\[30\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=documentation%20are%20kept%20in%20sync,the%20order%20in). Keep docs updated as code changes. Use clear, concise language in documentation.

* **Testing:** Write unit tests (testthat) for all important logic. Use shinytest2 for Shiny modules. Ensure tests cover edge cases and use data.table-aware checks for tabular outputs. All tests should pass on CI.

* **Linting & CI:** Adhere to lintr style guidelines (tidyverse style). No lint errors or warnings. Code must pass R CMD check (including tests and examples) with no errors or warnings. CI pipelines will enforce this, so write code that is CRAN-quality[\[35\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Linting%3A%20We%20use%20lintr%20in,Note).

By following this guide, AI assistants and developers can produce code that seamlessly integrates with the Artalytics codebase, maintaining consistency, reliability, and clarity across all projects.

---

[\[1\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=All%20Artalytics%20R%20packages%20use,some%20additions%20for%20Shiny%20modules) [\[2\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=UI%20Module%20Packages%20%28Shiny,for%20the%20platform%E2%80%99s%20web) [\[3\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Directory%20Structure) [\[12\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=No%20Credentials%20in%20Repos%3A%20Never,Renviron%20%20that) [\[14\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=We%20maintain%20%20a%20,Key%20style%20guidelines%20include) [\[15\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Favor%20data,This%20also%20reduces) [\[16\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=than%20dplyr%20%20or%20other,This%20also%20reduces%20external%20dependencies) [\[17\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=String%20Handling%3A%20We%20prefer%20stringr,are%20complex%2C%20commented%20for%20clarity) [\[18\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Concatenation%3A%20Use%20paste0,makes%20the%20behavior) [\[19\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=external%20dependencies,style%20when%20it%20improves%20readability) [\[20\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Code%20Conciseness%3A%20Aim%20to%20write,Comments%20should%20be%20added%20for) [\[22\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Naming%20Conventions%3A%20Use%20snake_case%20,to%20ease%20navigation) [\[26\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=interface,share%20the%20platform%E2%80%99s%20coding%20conventions) [\[28\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=considerations%3A%20We%20may%20use%20snapshot,inputs) [\[29\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Snapshot%20and%20UI%20Testing%3A%20For,inputs) [\[30\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=documentation%20are%20kept%20in%20sync,the%20order%20in) [\[31\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Function%20Documentation%20and%20Export%3A%20All,ones%20often%20get%20a%20%40noRd) [\[32\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=testthat%20Framework%3A%20We%20use%20testthat,or%20R%20CMD%20check) [\[33\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Coverage%20of%20Core%20Logic%3A%20Tests,return%20a) [\[34\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=R%20CMD%20Check%3A%20Every%20package,expected%20to%20run%20R%20CMD) [\[35\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Linting%3A%20We%20use%20lintr%20in,Note) [\[36\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Documentation%20of%20Deviations%3A%20This%20AGENTS,For) [\[37\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=Favor%20data,This%20also%20reduces%20external%20dependencies) [\[38\]](file://file-6kXMpf9vkZckmTZjQ8ycPR#:~:text=external%20dependencies,especially%20for%20sequential) Artalytics R Packages – AGENTS Guidelines.pdf

[file://file-6kXMpf9vkZckmTZjQ8ycPR](file://file-6kXMpf9vkZckmTZjQ8ycPR)

[\[4\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=The%20Artalytics%20platform%20is%20composed,with%20a%20layered%20dependency%20structure) [\[5\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=Functional%20packages%20like%20artopenai%20,should%20not%20depend%20on) [\[6\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=uploads) [\[7\]](file://file-FH8SLyKjKMRGnqKvkUNfM1#:~:text=Shiny%20modules%20like%20modUpload%20%2C,These%20modules%20use%20artutils) Restructuring Artalytics Package Dependencies.pdf

[file://file-FH8SLyKjKMRGnqKvkUNfM1](file://file-FH8SLyKjKMRGnqKvkUNfM1)

[\[8\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=Problem%3A%20The%20above%20approach%20conflicts,goal%20is%20to%20treat%20the) [\[9\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=explicitly%20state%20that%20no%20package,deployability%20and%20ensuring%20consistency%20across) [\[10\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=tags%24link%28rel%3D) [\[11\]](file://file-4JGfzW4k2CZyofSHxJFnFg#:~:text=Use%20CDN%20for%20Logo%20and,For%20example) Overview of Pixelsense2 Asset Usage (Current State).pdf

[file://file-4JGfzW4k2CZyofSHxJFnFg](file://file-4JGfzW4k2CZyofSHxJFnFg)

[\[13\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=Deprecated%20Env%20Variables%3A%20While%20the,They%20should%20be%20renamed%20for) [\[24\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=solution%20%28e,isn%E2%80%99t%20wrapped%20in%20a) [\[25\]](file://file-HYka3rrcSVubsPchHcyXRr#:~:text=Lack%20of%20Error%20Handling%3A%20The,ART_USE_PG_CONF%20%20is%20unset) Modernization Plan for \`certSearch\` Shiny App.pdf

[file://file-HYka3rrcSVubsPchHcyXRr](file://file-HYka3rrcSVubsPchHcyXRr)

[\[21\]](https://github.com/artalytics/artutils/blob/e3fcb8f371ecaf9d75e9ee7f7827c1c299181a4f/R/getImageRaster.R#L7-L14) getImageRaster.R

[https://github.com/artalytics/artutils/blob/e3fcb8f371ecaf9d75e9ee7f7827c1c299181a4f/R/getImageRaster.R](https://github.com/artalytics/artutils/blob/e3fcb8f371ecaf9d75e9ee7f7827c1c299181a4f/R/getImageRaster.R)

[\[23\]](https://github.com/artalytics/modUpload/blob/f7cefc760bb20b73dc8259a1723b81262980c3ad/R/app-server.R#L31-L38) app-server.R

[https://github.com/artalytics/modUpload/blob/f7cefc760bb20b73dc8259a1723b81262980c3ad/R/app-server.R](https://github.com/artalytics/modUpload/blob/f7cefc760bb20b73dc8259a1723b81262980c3ad/R/app-server.R)

[\[27\]](file://file-MzkyFMuCXvZa4EmWMTmKxM#:~:text=packages%20and%20the%20app%20launched,latest%20versions%20of%20these%20packages) Software\_Architecture\_Overview.pdf

[file://file-MzkyFMuCXvZa4EmWMTmKxM](file://file-MzkyFMuCXvZa4EmWMTmKxM)